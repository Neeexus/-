# 커맨드 패턴이란
- 실행될 기능을 ```캡슐화```함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴
   - 즉, 이벤트가 발생했을 때 실행될 기능이 다양하면서도 변경이 필요한 경우에 이벤트를 발생시키는 클래스를 변경하지 않고 재사용하고자 할 때 유용하다.
- 실행될 기능을 캡슐화함으로써 기능의 실행을 요구하는 호출자(Invoker) 클래스와 실제 기능을 실행하는 수신자(Receiver) 클래스 사이의 의존성을 제거하기.
- 따라서 ```실행될 기능의 변경에도 호출자 클래스를 수정 없이 그대로 사용``` 할 수 있도록 해준다.
- 역할이 수행하는 작업
   - Command
      - 실행될 기능에 대한 인터페이스
      - 실행될 기능을 excute 메서드로 선언함
   - ConcreteCommand
      - 실제로 실행되는 기능을 구현
      - 즉, Command라는 인터페이스를 구현하는 곳
   - Invoker
      -기능의 실행을 요청하는 호출자 클래스
   - Receiver
      - ConcreteCommand에서 execute 메서드를 구현할 때 필요한 클래스
      - 즉, ConcreteCommand의 기능을 실행하기 위해 사용하는 수신자 클래스






<details>
<summary>램프 코드</summary>

```.cs
 class Program
    {
        static void Main(string[] args)
        {
            Lamp lamp = new Lamp();
            Button lampButton = new Button(lamp);
            lampButton.pressed();
        }
    }
    public class Lamp
    {
        public void turnOn()
        {
            Console.WriteLine("Lamp On");
        }
    }
    public class Button
    {
        private Lamp theLamp;
        public Button(Lamp theLamp)
        {
            this.theLamp = theLamp;
        }
        public void pressed()
        {
            theLamp.turnOn();
        }
    }
```   


</details>

## 문제점
- 버튼을 눌렀을 때 다른 기능을 실행하는 경우
   - ex) 버튼을 눌렀을 때 알람이 시작되게 한다?

<details>
<summary>알람코드</summary>
   
```.cs
 public class Alram
 {
     public void start()
     {
         Console.WriteLine("굿모닝~ 빰빰빠 빠빰빠빠ㅃ빠빰");
     }
 }
 ```
   
</details>

   - 새로운 기능으로 변경하려고 기존 코드 (Button 클래스)의 내용을 수정해야함 => #1 OCP(Open Closed Principle) 위배
